<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Solving Doublets in Mathematica</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/base.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Solving Doublets in Mathematica</h1>
</header>
<p><a href="/">← Back to main page</a></p>
<p>Doublets are a type of word puzzle invented by Lewis Carroll (author of “Alice in Wonderland”). The goal is to change one word into another by adding, removing, or changing one letter at a time. The tricky part is that each intermediate step must also be a valid word. For more information see <a href="http://thinks.com/puzzles/doublets.htm" class="uri">http://thinks.com/puzzles/doublets.htm</a>.</p>
<p>If we think of words as vertices in a graph, then two words are connected by an edge if the <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">edit distance</a> between them is exactly 1. Mathematica can then be used to solve a doublet with its shortest-path algorithm GraphPath.</p>
<figure>
<img src="mathematicadoublets.jpg" alt="" /><figcaption>Doublets</figcaption>
</figure>
<p>To see a real-time implementation of this you can take a look at my <a href="http://demonstrations.wolfram.com/Doublets/">Mathematica Doublets Demonstration</a>. This article goes into a bit more depth on how the demonstration was created. All the code is written for Mathematica 6.0.</p>
<p>First, let’s get a list of all lowercase 5-letter words.</p>
<pre class="mathematica"><code>d = DictionaryLookup[RegularExpression[&quot;[a-z]{1,5}&quot;]];</code></pre>
<p>It’s pretty big!</p>
<pre class="mathematica"><code>Length[d]
8508</code></pre>
<p>We’ll just take the first 1000 words for purposes of this example.</p>
<pre class="mathematica"><code>d = Take[d, 1000];</code></pre>
<p>Now we want to build up a graph <strong>g</strong> that shows which words are “connected” to each other i.e. have EditDistance == 1. This code is computationally intensive and takes about 20 minutes to run. Notice I have added a quick check at the beginning to skip out if the words differ in length by more than 1, since there is no way these two words could be connected in that case. I would welcome any way to optimize this code!</p>
<pre class="mathematica"><code>g = {};
Do[
 Do[
  If[Abs[StringLength[d[[i]]] - StringLength[d[[j]]]] &gt; 1, Continue[]];
  If[EditDistance[d[[i]], d[[j]]] == 1, AppendTo[g, d[[i]] -&gt; d[[j]]];
    AppendTo[g, d[[j]] -&gt; d[[i]]]],
  {j, i + 1, Length[d]}],
 {i, 1, Length[d]}]</code></pre>
<p>Let’s plot the graph to see which words are connected.</p>
<pre class="mathematica"><code>GraphPlot[g]</code></pre>
<figure>
<img src="full_graph.png" alt="" /><figcaption>Full Graph</figcaption>
</figure>
<p>There are quite a few little groups of words which are only connected to each other. We want to get rid of those and just keep the big cluster. The next step uses StrongComponents to automatically identify the biggest cluster and keep only that subset of the graph.</p>
<pre class="mathematica"><code>Needs[&quot;GraphUtilities`&quot;]

s = StrongComponents[g];</code></pre>
<p>We’ll sort the connected components by number of member words, and take the largest component (i.e. the big cluster in the picture above).</p>
<pre class="mathematica"><code>sc = Last[SortBy[s, Length]];</code></pre>
<p>Filter graph <strong>g</strong> to only include words which appear in <strong>gc</strong>, the biggest cluster.</p>
<pre class="mathematica"><code>gc = Select[g, MemberQ[sc, #[[1]]] &amp;];</code></pre>
<p>Confirm that we have correctly filtered and are left with a big group of words where you can go from any word to any other by just changing one letter (i.e. EditDistance == 1).</p>
<pre class="mathematica"><code>GraphPlot[gc]</code></pre>
<figure>
<img src="filtered_graph.png" alt="" /><figcaption>Filtered Graph</figcaption>
</figure>
<p>Let’s test that we can solve a doublet using the shortest-path algorithm built into Mathematica. We’ll find the shortest distance between the vertices “sleep” and “dream” in the graph <strong>gc</strong>.</p>
<pre class="mathematica"><code>GraphPath[gc, &quot;sleep&quot;, &quot;dream&quot;]

{&quot;sleep&quot;, &quot;seep&quot;, &quot;seem&quot;, &quot;seam&quot;, &quot;ream&quot;, &quot;dream&quot;}</code></pre>
</body>
</html>
